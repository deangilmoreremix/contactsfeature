import { supabase } from './supabaseClient';
import { logger } from './logger.service';
import { imageStorageService, type SavedImage } from './imageStorage.service';

export interface ImageGenerationRequest {
  prompt: string;
  variants?: number;
  aspect_ratio?: string;
  seeds?: string[];
  contact_id?: string;
  deal_id?: string;
  agent_id?: string;
  feature?: string;
  format?: string;
}

export interface ImageGenerationResult {
  success: boolean;
  images?: SavedImage[];
  error?: string;
  metadata?: {
    total_generated: number;
    model: string;
    cost_estimate: number;
  };
}

export interface AgentImageContext {
  contact?: {
    id: string;
    name: string;
    company?: string;
    industry?: string;
  };
  deal?: {
    id: string;
    name: string;
    value?: number;
    stage?: string;
  };
  campaign?: {
    id: string;
    name: string;
    type?: string;
  };
}

class ImageAgentService {
  private readonly GEMINI_FUNCTION_URL = '/.netlify/functions/gemini-image-generator';

  /**
   * Generate images for AI AE Agent (demo visuals)
   */
  async generateDemoVisuals(
    context: AgentImageContext,
    customPrompt?: string
  ): Promise<ImageGenerationResult> {
    try {
      const { contact, deal } = context;

      const prompt = customPrompt || this.buildDemoPrompt(contact, deal);

      const request: ImageGenerationRequest = {
        prompt,
        variants: 3,
        aspect_ratio: '16:9',
        ...(contact?.id && { contact_id: contact.id }),
        ...(deal?.id && { deal_id: deal.id }),
        agent_id: 'ai-ae-agent',
        feature: 'demo-visuals',
        format: 'presentation'
      };

      return await this.generateImages(request);
    } catch (error) {
      logger.error('Failed to generate demo visuals', error as Error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Generate email banner images
   */
  async generateEmailBanners(
    context: AgentImageContext,
    customPrompt?: string
  ): Promise<ImageGenerationResult> {
    try {
      const { contact, campaign } = context;

      const prompt = customPrompt || this.buildEmailBannerPrompt(contact, campaign);

      const request: ImageGenerationRequest = {
        prompt,
        variants: 2,
        aspect_ratio: '3:1',
        ...(contact?.id && { contact_id: contact.id }),
        agent_id: 'email-composer',
        feature: 'email-banners',
        format: 'banner'
      };

      return await this.generateImages(request);
    } catch (error) {
      logger.error('Failed to generate email banners', error as Error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Generate proposal thumbnail images
   */
  async generateProposalThumbnails(
    context: AgentImageContext,
    customPrompt?: string
  ): Promise<ImageGenerationResult> {
    try {
      const { deal, contact } = context;

      const prompt = customPrompt || this.buildProposalThumbnailPrompt(deal, contact);

      const request: ImageGenerationRequest = {
        prompt,
        variants: 4,
        aspect_ratio: '1:1',
        ...(deal?.id && { deal_id: deal.id }),
        ...(contact?.id && { contact_id: contact.id }),
        agent_id: 'deal-preparation',
        feature: 'proposal-thumbnails',
        format: 'thumbnail'
      };

      return await this.generateImages(request);
    } catch (error) {
      logger.error('Failed to generate proposal thumbnails', error as Error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Batch generate images for multiple contexts
   */
  async batchGenerateImages(
    requests: ImageGenerationRequest[]
  ): Promise<ImageGenerationResult[]> {
    const results: ImageGenerationResult[] = [];

    // Process in batches to avoid overwhelming the API
    const batchSize = 3;
    for (let i = 0; i < requests.length; i += batchSize) {
      const batch = requests.slice(i, i + batchSize);
      const batchPromises = batch.map(request => this.generateImages(request));
      const batchResults = await Promise.all(batchPromises);
      results.push(...batchResults);

      // Small delay between batches
      if (i + batchSize < requests.length) {
        await new Promise(resolve => setTimeout(resolve, 1000));
      }
    }

    return results;
  }

  /**
   * Get images generated by a specific agent
   */
  async getAgentGeneratedImages(
    agentId: string,
    contactId?: string,
    dealId?: string,
    limit = 20
  ): Promise<SavedImage[]> {
    try {
      let query = supabase
        .from('generated_images')
        .select('*')
        .eq('metadata->>agent_id', agentId)
        .order('created_at', { ascending: false })
        .limit(limit);

      if (contactId) {
        query = query.eq('metadata->>contact_id', contactId);
      }

      if (dealId) {
        query = query.eq('metadata->>deal_id', dealId);
      }

      const { data, error } = await query;

      if (error) {
        throw new Error(`Failed to fetch agent images: ${error.message}`);
      }

      return data || [];
    } catch (error) {
      logger.error('Failed to get agent generated images', error as Error);
      return [];
    }
  }

  /**
   * Regenerate image variants
   */
  async regenerateVariants(
    originalImageId: string,
    newVariants = 3
  ): Promise<ImageGenerationResult> {
    try {
      // Get original image metadata
      const { data: originalImage, error: fetchError } = await supabase
        .from('generated_images')
        .select('*')
        .eq('id', originalImageId)
        .single();

      if (fetchError || !originalImage) {
        throw new Error('Original image not found');
      }

      const metadata = originalImage.metadata;
      const request: ImageGenerationRequest = {
        prompt: metadata.prompt,
        variants: newVariants,
        aspect_ratio: metadata.aspect_ratio,
        seeds: [], // Could include original as seed
        contact_id: metadata.contact_id,
        deal_id: metadata.deal_id,
        agent_id: metadata.agent_id,
        feature: metadata.feature,
        format: metadata.format
      };

      return await this.generateImages(request);
    } catch (error) {
      logger.error('Failed to regenerate variants', error as Error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Core image generation method
   */
  private async generateImages(request: ImageGenerationRequest): Promise<ImageGenerationResult> {
    try {
      // Get authentication token
      const { data: { session } } = await supabase.auth.getSession();
      if (!session?.access_token) {
        throw new Error('User must be authenticated');
      }

      const response = await fetch(this.GEMINI_FUNCTION_URL, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
          'Authorization': `Bearer ${session.access_token}`
        },
        body: JSON.stringify(request)
      });

      if (!response.ok) {
        const errorData = await response.json();
        throw new Error(errorData.error || `HTTP ${response.status}`);
      }

      const result = await response.json();

      if (!result.success) {
        throw new Error(result.error || 'Generation failed');
      }

      // Convert the returned images to SavedImage format
      const images: SavedImage[] = result.images.map((img: any) => ({
        id: img.id,
        user_id: '', // Will be set by the function
        filename: img.filename,
        original_filename: img.filename,
        url: img.url,
        thumbnail_url: img.thumbnail_url,
        file_size: 0, // Will be set by storage service
        mime_type: 'image/png',
        metadata: img.metadata,
        created_at: new Date().toISOString(),
        updated_at: new Date().toISOString()
      }));

      logger.info('Images generated successfully', {
        count: images.length,
        agent: request.agent_id,
        feature: request.feature
      });

      return {
        success: true,
        images,
        metadata: result.metadata
      };

    } catch (error) {
      logger.error('Image generation failed', error as Error);
      return {
        success: false,
        error: error instanceof Error ? error.message : 'Unknown error'
      };
    }
  }

  /**
   * Build prompt for demo visuals
   */
  private buildDemoPrompt(contact?: any, deal?: any): string {
    const company = contact?.company || 'the company';
    const industry = contact?.industry || 'technology';
    const dealValue = deal?.value ? `$${deal.value.toLocaleString()}` : '';

    return `Create a professional demo visual for ${company} in the ${industry} industry.
    ${dealValue ? `Show value proposition for a ${dealValue} deal.` : ''}
    Modern, clean design with SmartCRM branding elements.
    Professional presentation style, suitable for sales demos.
    Include visual metaphors for growth, success, and innovation.
    High-quality, photorealistic style with proper lighting and composition.
    Aspect ratio 16:9 for presentation display.`;
  }

  /**
   * Build prompt for email banners
   */
  private buildEmailBannerPrompt(contact?: any, campaign?: any): string {
    const company = contact?.company || 'the company';
    const campaignType = campaign?.type || 'marketing';

    return `Create an email banner for ${company}.
    ${campaignType} campaign theme.
    Professional yet engaging design.
    Include call-to-action elements.
    SmartCRM brand colors and style.
    Clean typography, modern design.
    Optimized for email display, aspect ratio 3:1.
    High contrast, readable text elements.`;
  }

  /**
   * Build prompt for proposal thumbnails
   */
  private buildProposalThumbnailPrompt(deal?: any, contact?: any): string {
    const dealName = deal?.name || 'the proposal';
    const company = contact?.company || 'the client';

    return `Create a professional thumbnail image for ${dealName} proposal to ${company}.
    Business proposal aesthetic.
    Include elements representing value, trust, and professionalism.
    SmartCRM branding subtly integrated.
    Clean, modern design suitable for document covers.
    Square format, high quality, professional appearance.
    Visual elements that convey success and partnership.`;
  }
}

export const imageAgentService = new ImageAgentService();