const { GoogleGenerativeAI } = require('@google/generative-ai');
const { createClient } = require('@supabase/supabase-js');

const MODEL = "gemini-2.5-flash-image-preview";

// Initialize clients
const genAI = new GoogleGenerativeAI(process.env.VITE_GEMINI_API_KEY);
const supabase = createClient(
  process.env.SUPABASE_URL,
  process.env.SUPABASE_SERVICE_ROLE_KEY
);

exports.handler = async (event, context) => {
  // Only allow POST requests
  if (event.httpMethod !== 'POST') {
    return {
      statusCode: 405,
      body: JSON.stringify({ error: 'Method not allowed' })
    };
  }

  try {
    const {
      prompt,
      variants = 1,
      aspect_ratio = '1:1',
      seeds = [],
      contact_id,
      deal_id,
      agent_id,
      feature = 'general',
      format = 'image'
    } = JSON.parse(event.body);

    if (!prompt) {
      return {
        statusCode: 400,
        body: JSON.stringify({ error: 'Prompt is required' })
      };
    }

    // Get authenticated user
    const authHeader = event.headers.authorization || event.headers.Authorization;
    if (!authHeader || !authHeader.startsWith('Bearer ')) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Unauthorized' })
      };
    }

    const token = authHeader.substring(7);
    const { data: { user }, error: authError } = await supabase.auth.getUser(token);

    if (authError || !user) {
      return {
        statusCode: 401,
        body: JSON.stringify({ error: 'Invalid token' })
      };
    }

    // Rate limiting check (simplified - in production use Redis/external service)
    const rateLimitKey = `gemini_image_${user.id}`;
    const { data: rateLimitData } = await supabase
      .from('rate_limits')
      .select('count, reset_time')
      .eq('key', rateLimitKey)
      .single();

    const now = Date.now();
    const resetTime = rateLimitData?.reset_time || 0;
    let currentCount = rateLimitData?.count || 0;

    // Reset counter if time window passed (1 hour)
    if (now > resetTime) {
      currentCount = 0;
    }

    // Check rate limit (50 images per hour)
    if (currentCount >= 50) {
      return {
        statusCode: 429,
        body: JSON.stringify({
          error: 'Rate limit exceeded. Try again later.',
          retryAfter: Math.ceil((resetTime - now) / 1000)
        })
      };
    }

    // Prepare content for Gemini
    const contents = [{ text: prompt }];

    // Add seed images if provided
    if (seeds && seeds.length > 0) {
      for (const seed of seeds) {
        try {
          const response = await fetch(seed);
          const blob = await response.blob();
          const arrayBuffer = await blob.arrayBuffer();
          const base64 = Buffer.from(arrayBuffer).toString('base64');

          contents.push({
            inlineData: {
              mimeType: blob.type || 'image/png',
              data: base64
            }
          });
        } catch (error) {
          console.warn('Failed to process seed image:', error);
        }
      }
    }

    const model = genAI.getGenerativeModel({ model: MODEL });
    const generatedImages = [];

    // Generate variants
    for (let i = 0; i < Math.min(variants, 6); i++) {
      try {
        const result = await model.generateContent(contents);
        const response = await result.response;
        const parts = response.candidates?.[0]?.content?.parts || [];

        for (const part of parts) {
          if (part.inlineData?.data) {
            const mimeType = part.inlineData.mimeType || 'image/png';
            const base64Data = part.inlineData.data;
            
            // Save to Supabase Storage
            const filename = `gemini-${feature}-${format}-${Date.now()}-v${i + 1}.png`;
            const filePath = `${user.id}/${filename}`;

            // Convert base64 to buffer
            const buffer = Buffer.from(base64Data, 'base64');

            // Upload to Supabase Storage
            const { data: uploadData, error: uploadError } = await supabase.storage
              .from('generated-images')
              .upload(filePath, buffer, {
                contentType: mimeType,
                upsert: false
              });

            if (uploadError) {
              console.error('Upload error:', uploadError);
              continue;
            }

            // Get public URL
            const { data: { publicUrl } } = supabase.storage
              .from('generated-images')
              .getPublicUrl(filePath);

            // Save metadata to database
            const imageMetadata = {
              user_id: user.id,
              filename: filePath,
              original_filename: filename,
              url: publicUrl,
              thumbnail_url: null, // Will be generated by client-side service
              file_size: buffer.length,
              mime_type: mimeType,
              metadata: {
                prompt,
                feature,
                format,
                aspect_ratio,
                seeds_used: seeds?.length || 0,
                variants_generated: variants,
                gemini_model: MODEL,
                agent_id,
                contact_id,
                deal_id,
                generation_timestamp: new Date().toISOString(),
                tags: [`${feature}`, `${format}`, 'gemini-generated']
              }
            };

            const { data: savedImage, error: dbError } = await supabase
              .from('generated_images')
              .insert(imageMetadata)
              .select()
              .single();

            if (!dbError && savedImage) {
              generatedImages.push({
                id: savedImage.id,
                url: publicUrl,
                thumbnail_url: null,
                filename,
                metadata: savedImage.metadata
              });
            }
          }
        }
      } catch (variantError) {
        console.error(`Variant ${i + 1} generation failed:`, variantError);
        // Continue with other variants
      }
    }

    // Update rate limit
    await supabase
      .from('rate_limits')
      .upsert({
        key: rateLimitKey,
        count: currentCount + 1,
        reset_time: resetTime > now ? resetTime : now + (60 * 60 * 1000) // 1 hour
      });

    // Track cost (simplified - in production integrate with billing service)
    const costEstimate = generatedImages.length * 0.02; // $0.02 per image estimate
    await supabase
      .from('usage_tracking')
      .insert({
        user_id: user.id,
        service: 'gemini_image_generation',
        cost: costEstimate,
        metadata: {
          images_generated: generatedImages.length,
          model: MODEL,
          agent_id,
          contact_id,
          deal_id
        }
      });

    return {
      statusCode: 200,
      body: JSON.stringify({
        success: true,
        images: generatedImages,
        metadata: {
          total_generated: generatedImages.length,
          model: MODEL,
          cost_estimate: costEstimate
        }
      })
    };

  } catch (error) {
    console.error('Gemini image generation error:', error);
    return {
      statusCode: 500,
      body: JSON.stringify({
        error: 'Internal server error',
        message: error.message
      })
    };
  }
};
